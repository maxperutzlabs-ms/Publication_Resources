---
title: "Interference Modelling in MS2-quantified multiplex proteomics"
author: "Moritz Madern"
date: "2022-12-13"
output: html_document
---

Data input:
1) MaxQuant PSM-table (named "msms.txt")    
2) thermo raw-files
3) rawStallion tool
4) isotopic impurity Matrix
5) functions contained in "functions_IM.R"

Data output:
1) modified PSM-table named "PSM.txt"


This script extracts relevant information from the Thermo raw files, and then models ion interference on PSM-level. Based on the trained model, PSM-wise "estimated interference level" (EIL) values will be estimated. Further, interference-corrected intensities will be calculated. Finally, reporter ion intensities (both interference-corrected and non-corrected) will be aggregated to higher feature levels (peptides, proteins).
Note: This script supports MaxQuant output as well as FragPipe output.

```{r Load required packages and functions, echo=FALSE, message=FALSE}

## Load packages. If not installed yet, install them prior to running this script!
library(ggplot2)
library(readr)
library(pracma)
library(tidyverse)
library(plot3D)
library(RColorBrewer)
library(MASS)       
library(gridExtra)
library(rlist)
library(foreach)
library(doParallel)
library(fields)
library(cowplot)
library(MSnbase)    ## Bioconductor
library(limma)      ## Bioconductor
library(msqrob2)    ## Bioconductor
library(DESeq2)     ## Bioconductor


## Source functions from functions.R (contains the larger functions of this script)
source("./functions_IM.R")


## Create Results folder
if (!file.exists("Results")){
  dir.create("Results")
}

```


```{r Specify required parameters, echo=FALSE}

## Specify file path to the folder where Thermo raw files (ending with "*.raw") of the experiment are stored.
rawfilefolder_filepath = "./rawfiles"

## Specify file path to rawStallion.exe, a C#-tool for extracting noise values among other information from the *.raw files. Download here: https://github.com/fstanek/rawStallion.
rawStallion.exe_filepath = "./rawStallion/rawStallion.exe"

## Specify file path to the PSM-table generated by database searching (in MaxQuant the corresponding table is called msms.txt).
msms_filepath = "./msms.txt"

## Optional: Specify specific pattern of raw file names which matches the raw files to be processed. Only relevant if not all of the PSMs in your PSM table are to be processed in script (e.g. because some come from MS3 measurements, etc.). If all raw files are to be processed, specify parameter as empty character "".
rawfile_pattern_to_keep = "phospho"

## Specify name of the column denoting raw file identity for each PSM (=row) in the PSM-table. It will later be renamed as "Raw.file".
rawfile_columnname = "Raw.file"

## Specify name of the column denoting scan number for each PSM (=row) in the PSM-table. It will later be renamed as "Scan.number".
scannumber_columnname = "Scan.number"

## Specify name of the column denoting precursor ion charge for each PSM (=row) in the PSM-table. It will later be renamed as "Charge".
charge_columnname = "Charge"

## Specify name of the column denoting retention time for each PSM (=row) in the PSM-table. It will later be renamed as "Retention.time".
retentionTime_columnname = "Retention.time"

## Specify name of the column denoting precursor peptide amino acid sequence for each PSM (=row) in the PSM-table. It will later be renamed as "Sequence".
sequence_columnname =  "Sequence"

## Specify name of the column denoting protein identity for each PSM (=row) in the PSM-table.
proteinGroup_columnname = "Proteins"

## Specify the search engine that was used to generate the PSM-table. Supported search engines so far: "MaxQuant", "FragPipe". The script might have to be adapted for other input sources.
search_engine = "MaxQuant"

## Specify the multiplexing labels used in the experiment. This parameter should be set as an object of the "ReporterIons" class used in the Bioconductor package "MSnBase", which comes with TMT6, TMT10, TMT11 and TMT16 as predefined objects. For more information, please see: https://lgatto.github.io/MSnbase/reference/ReporterIons-class.html.
reporter_ions = TMT16

## Optional: Correct for isotopic impurities of reporter ions by specifying an impurity matrix. If this step is to be skipped, set the parameter to NULL. Else, specify a purity correction matrix as an nxn matrix, where n is the number of channels in the kit (directly reading in a file from your computer is also fine). Columns represent reporter channels, and rows represent relative signal percentages. The order of columns and rows has to match that of the object reporter_ions specified above. For more information on how to construct an impurity matrix, please refer to the respective guide from "MSnBase": https://rdrr.io/github/lgatto/MSnbase/man/purityCorrect-methods.html. If no impurity correction should be performed, set this parameter to NULL.
impuritymatrix = as.matrix(read.csv(file="./impurity_matrix_tmtpro.csv" , sep=",", header=TRUE, row.names = 1))  

## Specify name of the column denoting the precursor peptide modified amino acid sequence for each PSM (=row) in the PSM-table. This is required to infer specific peptide characteristics. In MaxQuant, this column is called "Modified.Sequence". An example entry is: "_(Acetyl (Protein N-term))SWQAYTDNLIGTGK_".
modifiedSequence_columnname = "Modified.sequence"

## Specify the TMT search setting as either "fixed" or "variable". If "fixed", it is assumed that sequences in the "Modified.Sequence" column will not show the TMT modification if found on the peptide. If "variable", it is assumed that a TMT-modification will be listed in the "Modified.Sequence" column at the respective position in the peptide's sequence. In that case, also specify the corresponding label pattern in the "Modified.Sequence" column as a regular expression pattern.
TMT_search_setting = "fixed"
label_pattern = ""

## Specify the pattern of acetylation (encompassing both N-terminal and Lysine acetylation) in the "Modified.Sequence" column as a regular expression pattern. This is crucial for correctly calculating the number of TMT-labels per peptide.
acetylation_pattern = "Acetyl"

## Optional: Specify an additional pattern for PTMs in the "Modified.Sequence" column as a regular expression pattern. This will help accounting for differences in fragmentation efficiencies in the model. Default Note: It is assumed that this PTM does not confer an additional charge to the peptide under measurement conditions. If no special PTM pattern is present, specify as empty character "".
ptm_pattern = ""

## specify the normalization strategy to be applied on reporter ion intensities. Supported is "loess" and "DESeq". Normalization is required prior to interference-correction (which assumes an uniform interference backround).
norm_strategy = "loess"

## Optional: Specify sample groups vector as character vector to perform filtering PSMs based on a minimum valid values threshold in at least 1 group. The order of entries should match the order of the reporter ion columns in your PSM-table.
groups = c("blank", "blank", "blank", "Group0", "Group6", "Group0", "Group6", "Group0", "Group6","blank", "Group9", "Group12", "Group9", "Group12", "Group9", "Group12")
minimum_valid_threshold = 3

## Optional: Specify the sample group names that represent empty channels in the input data  (e.g. in case when using 16plex kit but only 12 channels are being used for labeling). Their respective reporter ion columns will be filtered out. This parameter requires specification of the empty group label as listed in the parameter "groups" above. If no group name corresponds to empty channels, specify as NULL.
groups_empty = "blank"





## note: Parameters that are described as "Optional" can be ignored if certain steps are to be skipped. 
## note: If specified correctly, no other user input is required for the remainder of the script!
## note: If the script produces any errors, please check if all parameters were specified correctly!

```


```{r Read in PSM-table, echo=FALSE}

## Read in PSM-table:
df_msms <- read.delim(file=msms_filepath, header=TRUE, stringsAsFactors = FALSE, sep="\t") 
writeLines("Dimensions of PSM-table:")
dim(df_msms)


## Rename some columns names to match them to the default-values of parameters of downstream functions and plots:
names(df_msms)[names(df_msms) == rawfile_columnname] <- "Raw.file"
names(df_msms)[names(df_msms) == scannumber_columnname] <- "Scan.number"
names(df_msms)[names(df_msms) == charge_columnname] <- "Charge"
names(df_msms)[names(df_msms) == retentionTime_columnname] <- "Retention.time"
names(df_msms)[names(df_msms) == proteinGroup_columnname] <- "Proteins"
names(df_msms)[names(df_msms) == sequence_columnname] <- "Sequence"
names(df_msms)[names(df_msms) == modifiedSequence_columnname] <- "Modified.sequence"


## If search_engine is FragPipe, modify columns appropriately to how they are needed
if (search_engine == "FragPipe"){
  # extract spectrum number matching fragpipe "Spectrum" column pattern and convert it into numeric vector
  scannr <- substring(df_msms$Scan.number, first=1, last= nchar(df_msms$Scan.number) -2)
  ind_last_point <- gregexpr(scannr, pattern="[.]") %>% sapply(., FUN="[", 2)
  scannr <- substring(scannr, first=ind_last_point + 1, last=nchar(scannr))
  df_msms$Scan.number <- as.numeric(scannr)
  
  # remove "pep.xml" in the rawfile column. also rmove "interact-" at the front.
  df_msms$Raw.file <- sub(df_msms$Raw.file, pattern="[.]pep[.]xml", replacement = "")
  df_msms$Raw.file <- sub(df_msms$Raw.file, pattern="interact-", replacement = "")
}


## If search_engine is MaxQuant, filter out second peptides, reverse hits and contaminants
if (search_engine == "MaxQuant"){
  # get rid of second peptides:
  df_msms <- df_msms[df_msms$Type != "MULTI-SECPEP",]
  dim(df_msms)
  # get rid of reverse hits:
  df_msms <- df_msms[!df_msms$Reverse=="+",]
  dim(df_msms)
  # get rid of contaminants:
  con_bool <- grepl(df_msms$Proteins, pattern="^CON")
  df_msms <- df_msms[!con_bool,]
  writeLines("\nDimension of PSM-table after filtering out second peptides, reverse and CONs:")
  print(dim(df_msms))
}


## Filter for raw files with specific pattern as specified via rawfile_pattern_to_keep parameter
if (!is.null(rawfile_pattern_to_keep)){
  df_msms <- df_msms[grepl(df_msms$Raw.file, pattern=rawfile_pattern_to_keep),]
}
writeLines("\nThe PSMs of these raw files will be processed:")
table(df_msms$Raw.file)


## Establish unique PSM identifier column called "unique_id"
df_msms$unique_id <- paste0(df_msms$Raw.file,"_",df_msms$Scan.number)


## Sort PSM-table by raw-file column
df_msms <- df_msms[order(df_msms$Raw.file),]

```


```{r Use rawStallion to read relevant information from Thermo raw files and write as R-readable .tsv files, echo=FALSE}

## Prepare parallel processing
cores <- detectCores(logical = TRUE)
cl <-makeCluster(cores - 2)
registerDoParallel(cl=cl)


## Execute rawStallion via command line (note: rawStallion requires a Windows OS)
invisible(
  foreach(i = list.files(rawfilefolder_filepath, full.names = TRUE)) %dopar% {
    system2(command = rawStallion.exe_filepath, args = i)
  }
)
print("Done.")
stopCluster(cl)


## Note: This code section should produce two .tsv-files for each of the .raw files in the folder "rawfilefolder_filepath". If this code does not work, you might need to install some Windows extension, e.g. Windows .Net Desktop Runtime. I recommend running rawStallion.exe in the command line first (not via R) to see if and what exactly is missing! Windows will complain to you which exact extension is missing. 
## Note: To run rawStallion via the command line, type the following line in the Windows command line:
# [rawStallion.exe-filepath] [rawfile-filepath]   
# where [rawStallion.exe-filepath] is the filepath to the rawStallion.exe file, and
# [rawfile-filepath] is the filepath to a single Thermo .raw file

```


```{r Extract spectral features for each PSM from the raw data, echo=FALSE}

## Prepare parallel processing
cores <- detectCores(logical = TRUE)
cl <- makeCluster(cores - 1)
registerDoParallel(cl=cl)


## Apply function (see functions.R) to extract spectral features (noise values, reporter ion intensities, PPF, etc.) from raw file data
t1 <- Sys.time() 
spectral_features <- extract_spectral_features_in_parallel(rawfilefolder_filepath = rawfilefolder_filepath, 
                                                               msms = df_msms,
                                                               scan_number = "Scan.number",
                                                               rawfile = "Raw.file",
                                                               charge = "Charge",
                                                               reporter_ions = reporter_ions,
                                                               mass_error_tolerance = 0.005)
stopCluster(cl)
t2 <- Sys.time()
writeLines("Duration of spectral feature extraction: ")
print(t2 - t1)


## Check if objects can be merged
if (!all(spectral_features$key_msms == df_msms$unique_id)){
  writeLines(warning("The two objects differ in order"))
}


## Merge spectral features to PSM table (df_msms)
df_msms <- cbind(df_msms, spectral_features[,-which(names(spectral_features) == "key_msms")])


## In case PSM-table was msms.txt from MaxQuant, and search setting was "fixed", the PSM-table already has a PIF-column. Compare MaxQuants PIF with calculated PPF:
if ("PIF" %in% names(df_msms)) {plot(x=df_msms$PIF, y=df_msms$PPF, cex=0.1, xlab="PIF",ylab="PPF")}
if ("PIP" %in% names(df_msms)) {plot(x=df_msms$PIP, y=df_msms$PPF, cex=0.1, xlab="PIP",ylab="PPF")}


## Visualization of some of the calculated variables
barplot(table(df_msms$parent_MS1), main="MS1-occurence of precursor peptide ion", xlab="MS1", border="grey")
hist(df_msms$PPF, main="Distribution of Precursor Purity Fraction", xlab="Precursor Purity Fraction (PPF)", border="grey", col="grey")
ggplot(df_msms) +
  geom_line(aes(x=Retention.time, y=noiseValue, col=Raw.file)) +
  theme(legend.position = "bottom") 


## Save session image after MS1 feature extraction. Can be loaded at a later stage via load().
save.image(paste0("session_including_MS1_features_",Sys.Date(),".RData"))

```


```{r OPTIONAL: Load previous result of feature extraction code block, echo=FALSE}

# load("session_including_MS1_features_2022-12-13")

```


```{r Correct for isotopic impurities via specified impurity matrix, echo=FALSE}

## Infer reporter ion column names (Note: pattern = "reporters_" will retrieve reporter ion intensities extracted in the step above. You can also use the reporter ion columns from your  search engine, but they have to be untransformed and normalized by injection time via division!)
names_reporterCol <- grep(names(df_msms), pattern="reporters_", value=TRUE)


## Perform impurity correction if impurity matrix was specified
if (!is.null(impuritymatrix)){
  
  # Invert impurity matrix to be used to correct for isotopic impurities
  writeLines("Impurity Matrix:")
  print(impuritymatrix)
  inverted_transposed_impuritymatrix <- solve(t(impuritymatrix))  # using linear algebra, this inverted matrix is later used to calculate the corrected intensities
  
  # Calculate impurity correction:
  m_uncorrected <- as.matrix(df_msms[,names_reporterCol])
  m_uncorrected[is.na(m_uncorrected)] <- 0
  rownames(m_uncorrected) <- df_msms$unique_id
  m_corrected <- m_uncorrected
  for (i in 1:nrow(m_uncorrected)) {
    # extract row_i
    row_i <- m_uncorrected[i,]
    row_i
    
    # calculate corrected intensities, replace any negative values with 0
    row_i_corrected <- inverted_transposed_impuritymatrix %*% row_i
    row_i_corrected <- pmax(row_i_corrected,0)
    
    # store in m_corrected 
    m_corrected[i,] <- row_i_corrected
  }
  
  # Finally, replace values that were originally 0 again with 0 (i.e. NA). Else they would mimic real observed intensities, which they are not!
  m_corrected[m_uncorrected == 0] <- 0
  
  # Plot before and after correction:
  par(mfrow=c(1,2))
  barplot(colSums(m_uncorrected, na.rm = TRUE), las=2, main="colSums before impurity correction", cex.names = 0.7, border="grey")
  barplot(colSums(m_corrected,na.rm=TRUE), las=2, main="colSums after impurity correction", cex.names = 0.7, border="#20217E", col="#20217E")
  
  # Replace uncorrected intensities in df_msms with corrected intensities:
  df_msms[,names_reporterCol] <- m_corrected
}

```


```{r OPTIONAL: Kick out reporter ion intensity columns of empty channels, echo=FALSE}

## Check if parameters specify any empty reporter ion column
if (!is.null(groups) && !is.null(groups_empty)){
  
  # Extract metadata and reporter ion data
  df_reporter <- df_msms[,names_reporterCol]
  df_meta <- df_msms[,!names(df_msms) %in% names_reporterCol]
  
  # Subselect only non empty channels
  df_reporter_nonEmpty <- df_reporter[,!groups %in% groups_empty]
  
  # Reconstitute full dataframe
  df_msms <- cbind(df_meta, df_reporter_nonEmpty)
  
  # Print column names of reporter ion columns before and after filtering
  writeLines("Reporter ion column names before filtering:")
  print(names(df_reporter))
  writeLines("Reporter ion column names after filtering:")
  print(names(df_reporter_nonEmpty))
  
  # redefine the object names_reporterCol (needed downstream)
  names_reporterCol <- names(df_reporter_nonEmpty)
  groups <- groups[!groups %in% groups_empty]
}

```


```{r Calculate number of TMT-labels per precursor peptide, echo=FALSE}

## Calculate the number of TMT-labels for each PSM precursor peptide ion if TMT labels were specified as fixed in the database search (i.e. TMT-labels are not shown in the Modified.Sequence column).
if (TMT_search_setting == "fixed"){
  mod_sequence <- df_msms$Modified.sequence
  number_K <- gregexpr(text= mod_sequence, pattern="K[^)]")     # excluding ) because of patterns like  "K (Acetyl K)" for example.
  number_K <- sapply(number_K, FUN= ">", 0)
  number_K <- sapply(number_K, FUN=sum)
  numberAc <- gregexpr(text = mod_sequence, pattern = acetylation_pattern)
  numberAc <- sapply(numberAc, FUN= ">", 0)
  numberAc <- sapply(numberAc , FUN=sum)
  number_labels <- number_K + 1 - numberAc    # + 1 because of N-terminal amino group
  df_msms$number_labels <- number_labels
}


## Calculate the number of TMT-labels for each PSM precursor peptide ion if TMT labels were specified as variable in the database search (i.e. TMT-labels are not shown in the Modified.Sequence column).
if (TMT_search_setting == "variable"){
  mod_sequence <- df_msms$Modified.sequence
  number_labels <- gregexpr(text = mod_sequence, pattern = label_pattern)
  number_labels <- sapply(number_labels, FUN=">", 0)
  number_labels <- sapply(number_labels, FUN=sum)
  df_msms$number_labels <- number_labels
}  

  
## Check for yourself in the first 30 rows if calculations are correct:
head(data.frame(Modified.Sequence = df_msms$Modified.sequence, Number_Labels= df_msms$number_labels), n=30)


## Plot overview of the number of TMT-labels per precursor peptide: 
barplot(table(df_msms$number_labels), main="number of TMT labels per peptides", ylab="frequency", border="grey")
  
```


```{r Calculate measurement run-specific peptide densities, echo=FALSE}

## Add column precursorIntensity to the dataframe (signal of precursor + isotopes in the isolation window)
df_msms$precursorIntensity <- df_msms$TIW*df_msms$PPF


## Calculate empirical peptide density estimated
peptide_density <- calculate_peptide_density(msms=df_msms,              # (see functions.R)
                                             rawfile = "Raw.file",
                                             retentionTime = "Retention.time",
                                             precursorMZ = "precursorMz", 
                                             modifiedSequence = "Modified.sequence",
                                             charge = "Charge",
                                             precursorIntensity = "precursorIntensity")     


## Add calculated peptide densities to the PSM-table (df_msms)
df_msms$peptideDensity <- peptide_density$peptideDensity


## Save session image after density estimation. Can be loaded at a later stage via load().
save.image(paste0("session_including_density_",Sys.Date(),".RData"))

```


```{r Generate dependent variable Y of multiple linear regression model (note: Y equals total reporter ion signal), echo=FALSE}

## Save copy of original PSM table, then filter away PSMs with 0 TMT labels
if( !exists("df_msms_original")) {
  df_msms_original <- df_msms
}
df_msms <- df_msms[!df_msms$number_labels == 0,]


## Extract reporter ion intensity matrix for modelling. Filter out rows (PSMs) with 0 total reporter ion signal.
m_reporter <- as.matrix(df_msms[,names_reporterCol])
df_msms <- df_msms[!rowSums(m_reporter, na.rm = TRUE) == 0,]


## Generate dependent model variable Y as total reporter ion intensity across all channels. 
m_reporter <- as.matrix(df_msms[,names_reporterCol])
df_msms$Y <- rowSums(m_reporter, na.rm=TRUE) 

```


```{r OPTIONAL: Filter out PSMs based on missing/valid values, echo=FALSE}

## Note: This section filters PSMs based on a minimum number threshold of valid values (i.e. non-NA values) in at least one group, if a group vector was specified.
if (!is.null(groups)){
  
  # Print "groups" and "minimum_valid_values" parameters
  writeLines("groups:")
  print(groups)
  writeLines("threshold of minimum valid values threshold in at least one group")
  print(minimum_valid_threshold)
  
  # For each PSM, calculate the maximum number of values across all groups
  m_reporter <- as.matrix(df_msms[,names_reporterCol])
  m_reporter[m_reporter == 0] <- NA
  v_max_valid_perGroup <- numeric(nrow(df_msms))
  for (i in 1:nrow(df_msms)){
    m_i <- m_reporter[i,]
    v_max_valid_perGroup[i] <- max(tapply(!is.na(m_i), INDEX = groups, FUN=sum))
  }
  
  # Visualize distribution of maximum number of valid values per group (across all groups)
  barplot(table(factor(v_max_valid_perGroup)), col="grey", border="grey", xlab="max # of valid values per group before filtering", ylab="frequency", main = "distribution before filtering")
  
  # Perform filtering based on valid values
  bool_keep <- v_max_valid_perGroup >= minimum_valid_threshold
  df_msms <- df_msms[bool_keep,]
}

```


```{r Generate explanatory variables (i.e. regressors Xi), warning=FALSE, echo=FALSE}

## 1) precursor: This variable describes the estimated intensity stemming from precursor peptide ions (including +1/-1 isotopes) in the total "peptide ion current" (PIC) of the MS2-scan.
df_msms$precursor <- df_msms$PIC * df_msms$PPF
writeLines("summary precursor:")
summary(df_msms$precursor)


## 2) nonprecursor: This variable describes the estimated intensity stemming from visible interfering non-precursor peptide ions in the total peptide ion current of the MS2-scan.
df_msms$nonprecursor <- df_msms$PIC* (1 - df_msms$PPF)
writeLines("\nsummary nonprecusor:")
summary(df_msms$nonprecursor)


## 3) noiseEstimate: This variable describes the estimated intensity stemming from interfering non-percursor peptide ions that are NOT visible in the isolation window range (in the MS1-scan), and are thus assumed to be equally invisible after fragmentation in the MS2 scan as they fall below the noise threshold in both spectra. 
df_msms$noiseEstimate <- df_msms$peptideDensity * df_msms$noiseValue
writeLines("\nsummary noiseEstimate:")
summary(df_msms$noiseEstimate)


## 4) rawfileID: This categorial variable describes the raw-file identity of the PSM. 
df_msms$rawfileID <- factor(df_msms$Raw.file)
writeLines("\nsummaryr rawfileID:")
summary(df_msms$rawfileID)


## 5) factorRawfileCharge: The charge state that the mass spectrometer assumed for the precursor peptide (which sometimes differs from the true charge state of the precursor peptide). NCE depends on this variable.
rawfileCharge <- df_msms$rawfileCharge
rawfileCharge[rawfileCharge > 3] <- 3
rawfileCharge[rawfileCharge < 3] <- 2
df_msms$factorRawfileCharge <- factor(rawfileCharge)
writeLines("\nsummary factorRawfileCharge:")
summary(df_msms$factorRawfileCharge)


## 6) pepChar: This categorical variable describes specific characteristics of a peptide that influence its fragmentation (and thus Y in the Model). Some other variables need to be calculated in advance.

# factorCharge_2, factorCharge_3 & factorCharge_4: These binary categorical variable describe the charge state of the precursor peptide. Charge states above 4 will be reclassified as 4 to ensure a sufficient number of observations in each category.These variables are needed for 9).
charge <- df_msms$Charge
df_msms$factorCharge_2 <- factor(ifelse(charge <= 2, yes="Charge2.yes", no="Charge2.no"))
df_msms$factorCharge_3 <- factor(ifelse(charge == 3, yes="Charge3.yes", no="Charge3.no"))
df_msms$factorCharge_4 <- factor(ifelse(charge >= 4, yes="Charge4.yes", no="Charge4.no"))
writeLines("\nsummary factorCharge:")
summary(df_msms$factorCharge_2)
summary(df_msms$factorCharge_3)
summary(df_msms$factorCharge_4)

# factorLabels_greater1 & factorLabels_greater2: These binary categorical variables describe the number of isobaric label molecules on the precursor peptide. These variables are needed for 9)
df_msms$factorLabels_1 <- factor(ifelse(df_msms$number_labels == 1, yes="Labels1.yes", no="Labels1.no"))
df_msms$factorLabels_2 <- factor(ifelse(df_msms$number_labels == 2, yes="Labels2.yes", no="Labels2.no"))
df_msms$factorLabels_3 <- factor(ifelse(df_msms$number_labels >= 3, yes="Labels3.yes", no="Labels3.no"))
writeLines("\nsummary factorLabels:")
summary(df_msms$factorLabels_1)
summary(df_msms$factorLabels_2)
summary(df_msms$factorLabels_3)

# contains_PTM: This binary categorical variable describes whether precursor peptide contains specified PTM.
df_msms$factor_PTM <- ifelse(grepl(df_msms$Modified.sequence, pattern=ptm_pattern), yes="yes", no="no")

# The following variables describe absence or presence of certain precursor peptide characteristics (amino acids and extra charge).
numberR <- df_msms$Sequence %>% 
    gregexpr(text=., pattern="R") %>% 
    sapply(., FUN=">", 0) %>% 
    sapply(., FUN=sum)   
df_msms$seqChar_R <- ifelse(numberR > 0, yes="R.yes", no= "R.no")
numberK <- df_msms$Sequence %>% 
    gregexpr(text=., pattern="K") %>% 
    sapply(., FUN=">", 0) %>% 
    sapply(., FUN=sum)
df_msms$seqChar_K <- ifelse(numberK > 0, yes="K.yes", no= "K.no")
numberH <- df_msms$Sequence %>% 
    gregexpr(text=., pattern="H") %>% 
    sapply(., FUN=">", 0) %>% 
    sapply(., FUN=sum)  
df_msms$seqChar_H <- ifelse(numberH > 0, yes="H.yes", no= "H.no")
numberD <- df_msms$Sequence %>% 
    gregexpr(text=., pattern="D") %>% 
    sapply(., FUN=">", 0) %>% 
    sapply(., FUN=sum)
df_msms$seqChar_D <- ifelse(numberD > 0, yes="D.yes", no= "D.no")
numberE <- df_msms$Sequence %>% 
    gregexpr(text=., pattern="E") %>% 
    sapply(., FUN=">", 0) %>% 
    sapply(., FUN=sum)
df_msms$seqChar_E <- ifelse(numberE > 0, yes="E.yes", no= "E.no")
df_msms$factorExtra <- ifelse(df_msms$Charge > df_msms$number_labels + numberR + numberH, yes="Extra.yes", no="Extra.no")

# calculation of variable pepChar.
pepChar <- rep("", times=nrow(df_msms))
for (i in unique(df_msms$rawfileID)){
  print(paste0("##### ", i , " #####"))
  df_msms_i <- df_msms %>% filter(rawfileID == i)
  pepChar_i <- determine_pepChar_classes(msms = df_msms_i,              # (see functions.R)
                                             Y_var = "Y",
                                             X_var = c("factorCharge_2",
                                                       "factorCharge_3",
                                                       "factorCharge_4",
                                                       "factorLabels_1",
                                                       "factorLabels_2",
                                                       "factorLabels_3",
                                                       "seqChar_D",
                                                       "seqChar_E",
                                                       "seqChar_R",
                                                       "seqChar_K",
                                                       "seqChar_H",
                                                       "factorExtra",
                                                       "factor_PTM",
                                                        min_number = 100))
  pepChar[df_msms$rawfileID == i] <- pepChar_i
}
df_msms$pepChar <- pepChar

# plot the classification results for the first raw file
df_msms_first <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1])
n_pepChar <- length(unique(df_msms_first$pepChar))
brewerpal_pepChar <- colorRampPalette(c("#F65A3D", "#FD0606","#B04433","#91760B", "#BAA857", "#A9DEE3", "#1A99B8", "#2171b5","#8C78A1","#0C0250"))
col_pepChar <- brewerpal_pepChar(n_pepChar)  

ggplot(df_msms_first) +   # barplot illustrating PSMs per class
  geom_bar(aes(y=pepChar,fill=pepChar)) +
  scale_fill_manual(values = col_pepChar)+
  theme_bw() +
  theme(legend.position = "none") 

ggplot(df_msms_first) +  # scatterplot: Y vs precursor Intensity
  geom_point(aes(x=precursorIntensity, y=Y, col=pepChar), cex=0.8, alpha=0.5) + 
  scale_color_manual(values = col_pepChar) +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  ylab("Total reporter ion signal (Y)") +
  xlab("Precursor ion Intensity") +
  theme_bw() +
  xlim(0, quantile(df_msms_first$precursorIntensity, 0.975)) +
  ylim(0, quantile(df_msms_first$Y, 0.975)) +
  theme(legend.position = "none")

ggplot(df_msms_first) +  # scatterplot: Y vs TIW
  geom_point(aes(x=TIW, y=Y, col=pepChar), cex=0.8, alpha=0.5) + 
  scale_color_manual(values = col_pepChar) +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  ylab("Total reporter ion signal (Y)") +
  xlab("Total intensity in isolation window (TIW)") +
  theme_bw() +
  xlim(0, quantile(df_msms_first$TIW, 0.975)) +
  ylim(0, quantile(df_msms_first$Y, 0.975)) +
  theme(legend.position = "none")

ggplot(df_msms_first) +  # scatterplot: Y vs PIC
  geom_point(aes(x=PIC, y=Y, col=pepChar), cex=0.8, alpha=0.5) + 
  scale_color_manual(values = col_pepChar) +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  ylab("Total reporter ion signal (Y)") +
  xlab("Total peptide ion currect (PIC)") +
  theme_bw() +
  xlim(0, quantile(df_msms_first$PIC, 0.975)) +
  ylim(0, quantile(df_msms_first$Y, 0.975))+
  theme(legend.position = "none")

ggplot(df_msms_first) + # scatterplot: Y vs TIW (log2-transformed)
  geom_point(aes(x=log2(TIW), y=log2(Y), col=pepChar), cex=0.8, alpha=0.5) + 
  scale_color_manual(values = col_pepChar) +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  ylab("log2 Total reporter ion signal ") +
  xlab("log2 Total intensity in isolation window")+
  theme_bw() +
  theme(legend.position = "none")

ggplot(df_msms_first) + # scatterplot: Y vs PIC (log2-transformed)
  geom_point(aes(x=log2(PIC), y=log2(Y), col=pepChar), cex=0.8, alpha=0.5) + 
  scale_color_manual(values = col_pepChar) +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  ylab("log2 Total reporter ion signal ") +
  xlab("log2 Total peptide ion current ")+
  theme_bw() +
  theme(legend.position = "none")

```


```{r OPTIONAL - Visualize Y/PIC ratios for all unique determined pepChars in rawfile q(which should be relatively constant within each class), echo=FALSE}

## Calculate signal to noise; and Y/PIC ratio
df_msms_first$SnN <- df_msms_first$precursor/df_msms_first$noiseValue
df_msms_first$Y_to_PIC <- df_msms_first$Y / df_msms_first$PIC
df_msms_first$log2__Y_to_PIC <- log2(df_msms_first$Y / df_msms_first$PIC)


## Create dataframe slightly modified for plotting (by replacing extreme values)
df_msms_plot <- df_msms_first
df_msms_plot <-  df_msms_plot %>% filter(SnN > quantile(SnN, probs=0.6),PPF > 0.6)
df_msms_plot$Y_to_PIC[df_msms_plot$Y_to_PIC > quantile(df_msms_plot$Y_to_PIC, probs=0.95)] <- quantile(df_msms_plot$Y_to_PIC, probs=0.95)
df_msms_plot$Y_to_PIC[df_msms_plot$Y_to_PIC < quantile(df_msms_plot$Y_to_PIC, probs=0.05)] <- quantile(df_msms_plot$Y_to_PIC, probs=0.05)


## Plot calculated ratios for all determined empirical peptide characteristics.
ggplot(data=df_msms_plot) +
  geom_point(aes(x=Retention.time, y=precursorMz, col=log2(Y_to_PIC))) +
  scale_color_gradientn(colors=pals::parula(20), name="log2 Y/PIC") +
  facet_wrap(~pepChar) +
  ggtitle("Y / PIC")

```


```{r Robust linear regression modelling of total reporter ion intensity, warning=FALSE, echo=FALSE}

## Calculate appropriate plot margins 
y_min <- log2(min(df_msms$Y)) - 0.5
y_max <- log2(max(df_msms$Y)) + 0.5


## 1) Estimate submodel: Y ~ 0 +  precursor 
if (length(unique(df_msms$rawfileID)) > 1){
  X <- model.matrix(data = df_msms,
                    object = ~ 0 + precursor:rawfileID)
  bool_keep <- apply(X, MARGIN = 2, FUN=function(x){length(unique(x)) > 1})
  X <- X[,bool_keep]  
} else {
  X <- model.matrix(data = df_msms,
                  object = ~ 0 + precursor)
}
interference_model <- rlm(y= df_msms$Y,
                            x = X,
                            psi = "psi.bisquare",
                            maxit = 10000)
main_plot <- "Y ~ 0 + precursor "
df_msms$fitted.values <- interference_model$fitted.values
df_msms_first <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1])
gg1 <- df_msms_first %>% 
       ggplot(data=.)+
       coord_cartesian(xlim=c(y_min,y_max),ylim=c(y_min,y_max)) +
       geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
       geom_point(aes(y=log2(Y),x=log2(fitted.values),col=as.factor(pepChar)), cex=1, alpha=0.5) +
       scale_color_manual(values = col_pepChar) +
       ylab("log2 Total reporter ion signal") + xlab("log2 fitted") +
       guides(colour = guide_legend(override.aes = list(size=3))) +  
       ggtitle(main_plot)  +
       theme_classic() + 
       theme(legend.position="none")
paste0("correlation (Y vs fitted) of model 1:  ", 
       round(cor(log2(df_msms_first$Y), log2(df_msms_first$fitted.values), use="pairwise.complete.obs"), digits=2))


## 2) Estimate submodel: Y ~ 0 +  precursor:pepChar 
if (length(unique(df_msms$rawfileID)) > 1){
  X <- model.matrix(data = df_msms,
                    object = ~ 0 + precursor:pepChar:rawfileID)
  bool_keep <- apply(X, MARGIN = 2, FUN=function(x){length(unique(x)) > 1})
  X <- X[,bool_keep]  
} else {
  X <- model.matrix(data = df_msms,
                  object = ~ 0 +
                             precursor:pepChar)
}
interference_model <- rlm(y= df_msms$Y,
                            x = X,
                            psi = "psi.bisquare",
                            maxit = 10000)
main_plot <- "Y ~ 0 + precursor:pepChar "
df_msms$fitted.values <- interference_model$fitted.values
df_msms_first <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1])
gg2 <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1]) %>% 
       ggplot(data=.)+
       coord_cartesian(xlim=c(y_min,y_max),ylim=c(y_min,y_max)) +
       geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
       geom_point(aes(y=log2(Y),x=log2(fitted.values),col=as.factor(pepChar)), cex=1, alpha=0.5) +
       scale_color_manual(values = col_pepChar) +
       ylab("log2 Total reporter ion signal") + xlab("log2 fitted") +
       guides(colour = guide_legend(override.aes = list(size=3))) +  
       ggtitle(main_plot)  +
       theme_classic() + 
       theme(legend.position="none")
paste0("correlation (Y vs fitted) of model 2:  ", 
       round(cor(log2(df_msms_first$Y), log2(df_msms_first$fitted.values), use="pairwise.complete.obs"), digits=2))
  

## 3) Estimate submodel: Y ~ 0 + precursor:pepChar + nonprecursor:rawfileCharge
if (length(unique(df_msms$rawfileID)) > 1){
  X <- model.matrix(data = df_msms,
                    object = ~ 0 + precursor:pepChar:rawfileID + nonprecursor:rawfileCharge:rawfileID)
  bool_keep <- apply(X, MARGIN = 2, FUN=function(x){length(unique(x)) > 1})
  X <- X[,bool_keep]  
} else {
  X <- model.matrix(data = df_msms,
                  object = ~ 0 + precursor:pepChar+ nonprecursor:rawfileCharge)
}
interference_model <- rlm(y= df_msms$Y,
                            x = X,
                            psi = "psi.bisquare",
                            maxit = 10000)
main_plot <- "Y ~ 0 + precursor:pepChar + nonprecursor:rawfileCharge "
df_msms$fitted.values <- interference_model$fitted.values
df_msms_first <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1])
gg3 <- df_msms_first %>% 
       ggplot(data=.)+
       coord_cartesian(xlim=c(y_min,y_max),ylim=c(y_min,y_max)) +
       geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
       geom_point(aes(y=log2(Y),x=log2(fitted.values),col=as.factor(pepChar)), cex=1, alpha=0.5) +
       scale_color_manual(values = col_pepChar) +
       ylab("log2 Total reporter ion signal") + xlab("log2 fitted") +
       guides(colour = guide_legend(override.aes = list(size=3))) +  
       ggtitle(main_plot)  +
       theme_classic() + 
       theme(legend.position="none")
paste0("correlation (Y vs fitted) of model 3:  ", 
       round(cor(log2(df_msms_first$Y), log2(df_msms_first$fitted.values), use="pairwise.complete.obs"), digits=2))


## 4) Estimate full model: Y ~ 0 + precursor:pepChar + nonprecursor:rawfileCharge + noiseEstimate
if (length(unique(df_msms$rawfileID)) > 1){
  X <- model.matrix(data = df_msms,
                    object = ~ 0 + precursor:pepChar:rawfileID + nonprecursor:rawfileCharge:rawfileID + noiseEstimate:rawfileID)
  bool_keep <- apply(X, MARGIN = 2, FUN=function(x){length(unique(x)) > 1})
  X <- X[,bool_keep]  
} else {
  X <- model.matrix(data = df_msms,
                  object = ~ 0 + precursor:pepChar + nonprecursor:rawfileCharge + noiseEstimate)
}
interference_model <- rlm(y= df_msms$Y,
                            x = X,
                            psi = "psi.bisquare",
                            maxit = 10000)
main_plot <- "Y ~ 0 + precursor:pepChar + nonprecursor:rawfileCharge + noiseEstimate "
df_msms$fitted.values <- interference_model$fitted.values
df_msms_first <- df_msms %>% filter(rawfileID == unique(df_msms$rawfileID)[1])
gg4 <- df_msms_first %>% 
       ggplot(data=.)+
       coord_cartesian(xlim=c(y_min,y_max),ylim=c(y_min,y_max)) +
       geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
       geom_point(aes(y=log2(Y),x=log2(fitted.values),col=as.factor(pepChar)), cex=1, alpha=0.5) +
       scale_color_manual(values = col_pepChar) +
       ylab("log2 Total reporter ion signal") + xlab("log2 fitted") +
       guides(colour = guide_legend(override.aes = list(size=3))) +  
       ggtitle(main_plot)  +
       theme_classic() + 
       theme(legend.position="none")
paste0("correlation (Y vs fitted) of model 4:  ", 
       round(cor(log2(df_msms_first$Y), log2(df_msms_first$fitted.values), use="pairwise.complete.obs"), digits=2))


## Plot prediction results 
gg1
gg2
gg3
gg4

```


```{r Calculation of model-based Estimated Interference Level (EIL) for all PSMs, echo=FALSE}

## Extract X-matrix. Differentiate between just one raw file vs multiple raw files
if (length(unique(df_msms$rawfileID)) > 1){
  X <- model.matrix(data = df_msms,
                    object = ~ 0 +
                               precursor:pepChar:rawfileID + nonprecursor:rawfileCharge:rawfileID + noiseEstimate:rawfileID )
  bool_keep <- apply(X, MARGIN = 2, FUN=function(x){length(unique(x)) > 1})
  X <- X[,bool_keep]  
} else {
  X <- model.matrix(data = df_msms,
                  object = ~ 0 +
                             precursor:pepChar + nonprecursor:rawfileCharge + noiseEstimate )
}


## Calculate estimates of precursor peptide-derived reporter ion signal (precursor estimate)
precursor_bool <- grepl(names(interference_model$coefficients), pattern="^precursor")
precursor_coefficients <- interference_model$coefficients[precursor_bool]
precursor_estimate <- X[,precursor_bool] %*% precursor_coefficients


## Calculate estimates of non-precursor peptide-derived reporter ion signal (non-precursor estimate)
nonprecursor_bool <- grepl(names(interference_model$coefficients), pattern="nonprecursor")
nonprecursor_coefficients <- interference_model$coefficients[nonprecursor_bool]
nonprecursor_estimate <- X[,nonprecursor_bool] %*% as.matrix(nonprecursor_coefficients)


## Calculate estimates of noise-derived reporter ion signal (noise estimate)
noise_bool <- grepl(names(interference_model$coefficients), pattern="noiseEstimate")
noise_coefficients <- interference_model$coefficients[noise_bool]
noise_estimate <- X[,noise_bool] %*% as.matrix(noise_coefficients)


## Plot decomposition of total estimated reporter ion signal based on model estimates:
m_signal_estimates <- data.frame(precursor_estimate = precursor_estimate, 
                                 nonprecursor_estimate = nonprecursor_estimate,
                                 noise_estimate = noise_estimate)
barplot(colSums(m_signal_estimates, na.rm=TRUE), main="Model-based decomposition of total reporter ion intensity", cex.names = 0.8, col=brewer.pal(n=4, "Pastel1"), border=brewer.pal(n=4, "Pastel1"))


## Calculate Estimated Interference Level (EIL), and add it to dataframe. Compare Estimated Interference Level (EIL) with 1- Isolation Window Purity (1-PPF)
df_msms$EIL <- pmax(pmin(1 - precursor_estimate/(precursor_estimate + nonprecursor_estimate + noise_estimate),1),0)
ylim_hist <- max(table(cut(df_msms$PPF, breaks = 50)))
par(mfrow=c(1,2))
hist(1 - df_msms$PPF, breaks=50, xlab="Isolation Window Impurity (1 - PPF)", main="", xlim=c(0,1), col="grey", border="grey", ylim=c(0,ylim_hist))
hist(df_msms$EIL, breaks=50, xlab="Estimated Interference Level (EIL)", main="", xlim=c(0,1), col="#20217E", border="#20217E", ylim=c(0,ylim_hist))

```


```{r Conduct normalization and replace unnormalized reporter ion columns, warning=FALSE, echo=FALSE}

## Display intensities before normalization
barplot(colSums(df_msms[,names_reporterCol], na.rm=TRUE), main="ColSums before normalization", las=2, cex.names=0.7, border="grey")
boxplot(log2(df_msms[,names_reporterCol]), las=2, main="log2 Intensities before normalization")


## Normalize reporter ion intensities
if (norm_strategy == "loess"){
  m_norm <- as.data.frame(loess_norm(m = as.matrix(df_msms[,names_reporterCol])))
}
if (norm_strategy == "DESeq"){
  m_norm <- as.data.frame(DESeq_norm(m = as.matrix(df_msms[,names_reporterCol])))
}
colnames(m_norm) <- paste0(colnames(m_norm), "_norm")


## Display intensities after normalization
barplot(colSums(m_norm, na.rm=TRUE), main="ColSums after normalization", las=2, cex.names=0.7, col="#20217E", border="#20217E")
boxplot(log2(m_norm), las=2, main="log2 Intensities after normalization", col="#20217E")


## Kick old reporter ion columns, add new normalized ones (getting rid of empty reporter ion channels in the processcolumns in the process)
df_msms <- df_msms[,!names(df_msms) %in% names_reporterCol]
df_msms <- cbind(df_msms,m_norm)


## Update parameter "names_reporterCol"
names_reporterCol <- colnames(m_norm)

```


```{r Calculate interference-corrected normalized reporter ion intensities based on EIL by arithmetic subtraction of interference, echo=FALSE}

## Perform interference correction
m_corrected <- interference_correction(reporterI_matrix = as.matrix(df_msms[,names_reporterCol]),  # (see functions.R)
                                        EIL = df_msms$EIL,
                                        max_interference = 0.8,
                                        min_intensity = df_msms$minIntensity_MS2) %>% as.data.frame()


## Add interference-corrected intensities to the data frame. Also store names of interference-corrected reporter intensity columns (needed for downstream aggregation of PSMs to peptides and proteins).
df_msms <- cbind(df_msms, m_corrected)
names_reporterCorr <- names(m_corrected)

```


```{r Export results table, echo=FALSE}

## Export the PSM table df_msms as "PSM.txt"
if (!file.exists("Results")){
  dir.create("Results")
}
write.table(df_msms, file = paste0(getwd(),"/Results/PSM.txt"), sep = "\t", col.names = TRUE, row.names=FALSE, quote=FALSE)


## Report the export
writeLines("The result table can be found in:")
print(paste0(getwd(),"/Results/PSM.txt"))


## Save session after EIL estimation and interference correction.Can be loaded at a later stage via load().
save.image(paste0("session_including_EILs_",Sys.Date(),".RData"))

```

This concludes the standard section of the script. In the section below, PSM reporter ion intensities and EIL values are additionally aggregated to peptides and proteins - however, it may be of interest to instead perform aggregation to features as defined by the search engine. Intensities can be aggregated by summation; metrics like EIL and PPF values can be aggregated by building weighted averages. In MaxQuant, output tables contain columns named "MS/MS IDs" that provide the necessary reference information to guide manual aggregation.


```{r Optional: Aggregate to Modified Peptide Level (by Modified Sequence column) and export result as table, echo=FALSE}

## Extract loop variable
unique_modSeq <- unique(df_msms$Modified.sequence)


## Initialize output
list_modpeptideTable <- vector(mode="list", length=length(unique_modSeq)) 
names(list_modpeptideTable) <- unique_modSeq


## Extract relevant information per feature and aggregate
for (i in unique_modSeq){
  bool_i <- df_msms$Modified.sequence == i
  df_i <- df_msms[bool_i,]
  dim(df_i)
  
  # calculate nrPSMs
  nrPSMs_i <- nrow(df_i)
  
  # extract protein name
  protein_i <- df_i$Proteins[1]
  
  # extract reporterIons and aggregate them by summation
  reporterIons_i <- df_i[,names_reporterCol]
  SummedreporterIons_i <- matrix(colSums(reporterIons_i, na.rm=TRUE),nrow=1,
                                  dimnames = list(NULL,names_reporterCol))
  
  # calculate mean intensity for each PSM of the peptide i, and total mean reporterIon intensity
  meanIntensity_i <- rowSums(reporterIons_i, na.rm=TRUE)
  SummedmeanIntensity_i <- sum(reporterIons_i, na.rm=TRUE)
  
  # aggregate PFF and EIL weighted by meanIntensity of each respective PSM
  weights_i <- meanIntensity_i/SummedmeanIntensity_i
  EIL_i <- sum(df_i$EIL*weights_i)
  PPF_i <- sum(df_i$PPF*weights_i)
  
  # extract corrected reporterIons and aggregate them by summation
  reporterIonscorr_i <- df_i[,names_reporterCorr]
  SummedreporterIonscorr_i <- matrix(colSums(reporterIonscorr_i, na.rm=TRUE),nrow=1,
                                             dimnames=list(NULL, names_reporterCorr))
  # store result in list
  list_modpeptideTable[[i]] <- cbind(data.frame(Proteins=protein_i, 
                                                ModifiedSequence=i,
                                                PPF=PPF_i, 
                                                EIL=EIL_i,
                                                nrPSMs = nrPSMs_i),
                                     as.data.frame(SummedreporterIons_i),
                                     as.data.frame(SummedreporterIonscorr_i))
}
df_modpeptide <- do.call(what="rbind", args=list_modpeptideTable)


## Export unique peptide feature table as "ModifiedPeptides.txt"
if (!file.exists("Results")){
  dir.create("Results")
}
write.table(df_modpeptide, file = paste0(getwd(),"/Results/ModifiedPeptides.txt"), sep = "\t", col.names = TRUE, row.names=FALSE, quote=FALSE)

```


```{r Optional: Aggregate to Peptide Level (by Sequence column) and export result as table, echo=FALSE}

## Extract loop variable
unique_seq <- unique(df_msms$Sequence)


## Initialize output
list_peptideTable <- vector(mode="list", length=length(unique_seq)) 
names(list_peptideTable) <- unique_seq

 
## Extract relevant information per feature and aggregate
for (i in unique_seq){
  bool_i <- df_msms$Sequence == i
  df_i <- df_msms[bool_i,]
  dim(df_i)
  
  ## calculate nrPSMs
  nrPSMs_i <- nrow(df_i)
  
  ## extract protein name
  protein_i <- df_i$Proteins[1]
  
  ## extract reporterIons and aggregate them by summation
  reporterIons_i <- df_i[,names_reporterCol]
  SummedreporterIons_i <- matrix(colSums(reporterIons_i, na.rm=TRUE),nrow=1,
                                  dimnames = list(NULL,names_reporterCol))
  
  ## calculate mean intensity for each PSM of the peptide i, and total mean reporterIon intensity
  meanIntensity_i <- rowSums(reporterIons_i, na.rm=TRUE)
  SummedmeanIntensity_i <- sum(reporterIons_i, na.rm=TRUE)
  
  ## aggregate PFF and EIL weighted by meanIntensity of each respective PSM
  weights_i <- meanIntensity_i/SummedmeanIntensity_i
  EIL_i <- sum(df_i$EIL*weights_i)
  PPF_i <- sum(df_i$PPF*weights_i)
  
  ## extract corrected reporterIons and aggregate them by summation
  reporterIonscorr_i <- df_i[,names_reporterCorr]
  SummedreporterIonscorr_i <- matrix(colSums(reporterIonscorr_i, na.rm=TRUE),nrow=1,
                                             dimnames=list(NULL, names_reporterCorr))
  
  ## store result in list
  list_peptideTable[[i]] <- cbind(data.frame(Proteins=protein_i, 
                                             Sequence=i,
                                             PPF=PPF_i, 
                                             EIL=EIL_i,
                                             nrPSMs = nrPSMs_i),
                                   as.data.frame(SummedreporterIons_i),
                                   as.data.frame(SummedreporterIonscorr_i))
}
df_peptide <- do.call(what="rbind", args=list_peptideTable)


## Export peptide table as "Peptides.txt"
if (!file.exists("Results")){
  dir.create("Results")
}
write.table(df_peptide, file = paste0(getwd(),"/Results/Peptides.txt"), sep = "\t", col.names = TRUE, row.names=FALSE, quote=FALSE)

```


```{r Optional: Aggregate to ProteinGroups Level (by msqrob2 smallestUniqueGroups function) and export result as table, echo=FALSE}

## Kick proteins that are ambiguous. This is a very conservative aggregation approach that does not consider any razor peptides
smallest_unique_protein_groups <- msqrob2::smallestUniqueGroups(df_msms$Proteins)
bool_keep <- df_msms$Proteins %in% smallest_unique_protein_groups
writeLines("Percent of PSMs kept when filtering for unambiguous protein IDs:")
mean(bool_keep)*100   
df_msms_filtered <- df_msms[bool_keep,]  


## Extract loop variable
unique_prot <- unique(df_msms_filtered$Proteins)


## Initialize output list
list_proteinTable <- vector(mode="list", length=length(unique_prot)) 
names(list_proteinTable) <- unique_prot


## Extract relevant information per feature and aggregate
for (i in unique_prot){
  bool_i <- df_msms_filtered$Proteins == i
  df_i <- df_msms_filtered[bool_i,]
  dim(df_i)
  
  ## calculate nrPSMs
  nrPSMs_i <- nrow(df_i)
  
  ## calculate nrPeptides
  nrPeptides_i <- length(unique(df_i$Sequence))
  
  ## extract protein name
  protein_i <- df_i$Proteins[1]
  
  ## extract reporterIons and aggregate them by summation
  reporterIons_i <- df_i[,names_reporterCol]
  SummedreporterIons_i <- matrix(colSums(reporterIons_i, na.rm=TRUE),nrow=1,
                                  dimnames = list(NULL,names_reporterCol))
  
  ## calculate mean intensity for each PSM of the peptide i, and total mean reporterIon intensity
  meanIntensity_i <- rowSums(reporterIons_i, na.rm=TRUE)
  SummedmeanIntensity_i <- sum(reporterIons_i, na.rm=TRUE)
  
  ## aggregate PFF and EIL weighted by meanIntensity of each respective PSM
  weights_i <- meanIntensity_i/SummedmeanIntensity_i
  EIL_i <- sum(weights_i * df_i$EIL)
  PPF_i <- sum(weights_i * df_i$PPF)
  
  ## extract corrected reporterIons and aggregate them by summation
  reporterIonscorr_i <- df_i[,names_reporterCorr]
  SummedreporterIonscorr_i <- matrix(colSums(reporterIonscorr_i, na.rm=TRUE),nrow=1,
                                             dimnames=list(NULL, names_reporterCorr))
  
  ## store result in list
  list_proteinTable[[i]] <- cbind(data.frame(Proteins=protein_i,
                                             PPF=PPF_i, 
                                             EIL=EIL_i,
                                             nrPSMs = nrPSMs_i,
                                             nrPeptides = nrPeptides_i),
                                   as.data.frame(SummedreporterIons_i),
                                   as.data.frame(SummedreporterIonscorr_i))
}
df_protein <- do.call(what="rbind", args=list_proteinTable)

## Export protein table as "Proteins.txt"
if (!file.exists("Results")){
  dir.create("Results")
}
write.table(df_protein, file = paste0(getwd(),"/Results/Proteins.txt"), sep = "\t", col.names = TRUE, row.names=FALSE, quote=FALSE)

```
 

```{r SPECIAL: For peptide, protein and filtered protein table, compare OIL vs EIL, echo=FALSE}

## Calculate observed Interference Level (OIL) for psm-table
m_reporter <- df_msms[,names_reporterCol]
groups_nonEmpty <- groups[!groups %in% groups_empty]
df_msms$OIL <- pmin(rowMeans(m_reporter[,groups_nonEmpty %in% c("Group0")])/rowMeans(m_reporter[,!groups_nonEmpty %in% c("Group0")]),1)
df_msms$OIL[is.na(df_msms$OIL)] <- 0
summary(df_peptide$OIL)


##  Calculate Observed Interference Level (OIL) for psm table
m_reporter <- df_peptide[,names_reporterCol]
groups_nonEmpty <- groups[!groups %in% groups_empty]
df_peptide$OIL <- pmin(rowMeans(m_reporter[,groups_nonEmpty %in% c("Group0")])/rowMeans(m_reporter[,!groups_nonEmpty %in% c("Group0")]),1)
summary(df_peptide$OIL)


##  Calculate Observed Interference Level (OIL) for peptide table
m_reporter <- df_peptide[,names_reporterCol]
groups_nonEmpty <- groups[!groups %in% groups_empty]
df_peptide$OIL <- pmin(rowMeans(m_reporter[,groups_nonEmpty %in% c("Group0")])/rowMeans(m_reporter[,!groups_nonEmpty %in% c("Group0")]),1)
summary(df_peptide$OIL)


##  Calculate Observed Interference Level (OIL) for proteintable
m_reporter <- df_protein[,names_reporterCol]
groups_nonEmpty <- groups[!groups %in% groups_empty]
df_protein$OIL <- pmin(rowMeans(m_reporter[,groups_nonEmpty %in% c("Group0")])/rowMeans(m_reporter[,!groups_nonEmpty %in% c("Group0")]),1)
summary(df_protein$OIL)


## Add organism column to psm table
bool_yeast <- grepl(df_msms$Proteins, pattern="YEAST") & !grepl(df_msms$Proteins, pattern="HUMAN")
df_msms$Organism <- ifelse(bool_yeast, yes="Y", no="H")
table(df_msms$Organism)


## Add organism column to peptide table
bool_yeast <- grepl(df_peptide$Proteins, pattern="YEAST") & !grepl(df_peptide$Proteins, pattern="HUMAN")
df_peptide$Organism <- ifelse(bool_yeast, yes="Y", no="H")
table(df_peptide$Organism)


## Add organism column to protein table
bool_yeast <- grepl(df_peptide$Proteins, pattern="YEAST") & !grepl(df_peptide$Proteins, pattern="HUMAN")
df_peptide$Organism <- ifelse(bool_yeast, yes="Y", no="H")
table(df_peptide$Organism)


## Add organism column to protein table
bool_yeast <- grepl(df_protein$Proteins, pattern="YEAST") & !grepl(df_protein$Proteins, pattern="HUMAN")
df_protein$Organism <- ifelse(bool_yeast, yes="Y", no="H")
table(df_protein$Organism)


## Filter protein table for at least 2 unique peptides
table(df_protein$number_uniquePeptide)
df_filteredprotein <- filter(df_protein, nrPeptides > 2)


## Filter for yeast features  in all tables
df_msms_yeast <- df_msms %>% filter(., Organism=="Y")
df_peptide_yeast <- df_peptide %>% filter(., Organism=="Y")
df_protein_yeast <- df_protein %>% filter(., Organism=="Y")
df_filteredprotein_yeast <- df_filteredprotein %>% filter(., Organism=="Y")


## Calculate EIL_OIL density
get_density <- function(x, y, ...) {
  dens <- MASS::kde2d(x, y, ...)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}
df_msms_yeast$eil_density <- get_density(y=df_msms_yeast$OIL, x=df_msms_yeast$EIL, n=1000)
df_peptide_yeast$eil_density <- get_density(y=df_peptide_yeast$OIL, x=df_peptide_yeast$EIL, n=1000)
df_protein_yeast$eil_density <- get_density(y=df_protein_yeast$OIL, x=df_protein_yeast$EIL, n=1000)
df_filteredprotein_yeast$eil_density <- get_density(y=df_filteredprotein_yeast$OIL, x=df_filteredprotein_yeast$EIL, n=1000)


## calculate PPF_OIL density
df_msms_yeast$ppf_density <- get_density(y=df_msms_yeast$OIL, x = 1 - df_msms_yeast$PPF, n=1000)
df_peptide_yeast$ppf_density <- get_density(y=df_peptide_yeast$OIL, x = 1 - df_peptide_yeast$PPF, n=1000)
df_protein_yeast$ppf_density <- get_density(y=df_protein_yeast$OIL, x = 1 - df_protein_yeast$PPF, n=1000)
df_filteredprotein_yeast$ppf_density <- get_density(y=df_filteredprotein_yeast$OIL, x = 1- df_filteredprotein_yeast$PPF, n=1000)


## create the EIL plots (OIL vs EIL)
gg_psm_eil <- df_msms_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=EIL, color=eil_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="Estimated Interference Level") +
          ggtitle("yeast PSMs") +
          theme_bw()
gg_pep_eil <- df_peptide_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=EIL, color=eil_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="Estimated Interference Level") +
          ggtitle("yeast peptides") +
          theme_bw()
gg_prot_eil <- df_protein_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=EIL, color=eil_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="Estimated Interference Level") +
          ggtitle("yeast proteins") +
          theme_bw()
gg_filteredprot_eil <- df_filteredprotein_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=EIL, color=eil_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="Estimated Interference Level") +
          ggtitle("yeast proteins, minimum 2 peptides") +
          theme_bw()


## create the EIL plots (OIL vs 1-PPF)
gg_psm_ppf <- df_msms_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=1-PPF, color=ppf_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="1 - Precursor Purity Fraction") +
          ggtitle("yeast PSMs") +
          theme_bw()
gg_pep_ppf <- df_peptide_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=1-PPF, color=ppf_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="1 - Precursor Purity Fraction") +
          ggtitle("yeast peptides") +
          theme_bw()
gg_prot_ppf <- df_protein_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=1-PPF, color=ppf_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="1 - Precursor Purity Fraction") +
          ggtitle("yeast proteins") +
          theme_bw()
gg_filteredprot_ppf <- df_filteredprotein_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=1-PPF, color=ppf_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="1 - Precursor Purity Fraction") +
          ggtitle("yeast proteins, minimum 2 peptides") +
          theme_bw()


## Combine plots to a single panel, and export it
grid <- plot_grid(gg_psm_ppf, gg_pep_ppf, gg_prot_ppf, gg_filteredprot_ppf,
                  gg_psm_eil, gg_pep_eil, gg_prot_eil, gg_filteredprot_eil, nrow=2)
grid



## create plots for paper
gg_pep_ppf <- df_peptide_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=1-PPF, color=ppf_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="1 - Precursor Purity Fraction") +
          theme_bw()
gg_pep_eil <- df_peptide_yeast %>%
          ggplot(.) + 
          geom_abline(intercept = 0, slope=1, col="black", cex=0.5, linetype=2) +
          geom_point(aes(y=OIL, x=EIL, color=eil_density), alpha=1, cex=1.5) +
          scale_color_gradientn(colors=pals::parula(20))+ 
          theme(legend.position=c(-0.3,0.5)) +
          coord_cartesian(xlim=c(0,1),ylim=c(0,1)) +
          labs(y="Observed Interference Level") + labs(x="Estimated Interference Level") +
          theme_bw()
pdf("SupFig6C.pdf",width=3.8, height=5)
plot_grid(gg_pep_ppf,gg_pep_eil,  nrow=2)
dev.off()


```






